// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Tabela deweloperów
model Developer {
  id                   String    @id @default(cuid())
  companyName          String    @map("company_name")
  legalForm            String?   @map("legal_form") // forma prawna
  krs                  String?   
  ceidg                String?
  nip                  String?
  regon                String?
  email                String    @unique
  phone                String?
  website              String?
  
  // Adres siedziby
  street               String?
  houseNumber          String?   @map("house_number")
  apartmentNumber      String?   @map("apartment_number")
  postalCode           String?   @map("postal_code")
  city                 String?
  municipality         String?   @map("municipality")
  county               String?   @map("county")
  voivodeship          String?   @map("voivodeship")
  
  status               DeveloperStatus @default(PENDING)
  harvesterConfigured  Boolean   @default(false) @map("harvester_configured")
  clientId             String    @unique @map("client_id") // dla URL-i
  
  createdAt            DateTime  @default(now()) @map("created_at")
  updatedAt            DateTime  @updatedAt @map("updated_at")
  
  // Relations
  user                 User?
  investments          Investment[]
  apartments           Apartment[]
  syncLogs             SyncLog[]
  
  @@map("developers")
}

// Tabela inwestycji
model Investment {
  id                   String    @id @default(cuid())
  developerId          String    @map("developer_id")
  name                 String    // nazwa inwestycji
  
  // Lokalizacja inwestycji
  street               String?
  houseNumber          String?   @map("house_number")
  postalCode           String?   @map("postal_code")
  city                 String?
  municipality         String?   @map("municipality")
  county               String?   @map("county")
  voivodeship          String?   @map("voivodeship")
  
  createdAt            DateTime  @default(now()) @map("created_at")
  updatedAt            DateTime  @updatedAt @map("updated_at")
  
  // Relations
  developer            Developer @relation(fields: [developerId], references: [id], onDelete: Cascade)
  apartments           Apartment[]
  
  @@map("investments")
}

// Tabela mieszkań
model Apartment {
  id                   String    @id @default(cuid())
  developerId          String    @map("developer_id")
  investmentId         String?   @map("investment_id")
  
  // Dane mieszkania
  apartmentNumber      String    @map("apartment_number") // Nr lokalu
  propertyType         PropertyType @map("property_type") // Lokal mieszkalny / Dom jednorodzinny
  
  // Powierzchnia
  usableArea           Float?    @map("usable_area") // m²
  
  // Ceny
  pricePerM2           Float     @map("price_per_m2") // Cena za m²
  basePrice            Float     @map("base_price") // Cena bazowa (iloczyn)
  finalPrice           Float     @map("final_price") // Cena finalna
  
  // Daty obowiązywania
  priceValidFrom       DateTime  @map("price_valid_from")
  priceValidTo         DateTime? @map("price_valid_to")
  
  // Dodatkowe elementy
  parkingSpaces        Json?     @map("parking_spaces") // Miejsca postojowe
  storageRooms         Json?     @map("storage_rooms") // Komórki lokatorskie
  relatedRooms         Json?     @map("related_rooms") // Pomieszczenia przynależne
  otherServices        Json?     @map("other_services") // Inne świadczenia
  
  createdAt            DateTime  @default(now()) @map("created_at")
  updatedAt            DateTime  @updatedAt @map("updated_at")
  
  // Relations
  developer            Developer @relation(fields: [developerId], references: [id], onDelete: Cascade)
  investment           Investment? @relation(fields: [investmentId], references: [id], onDelete: SetNull)
  priceHistory         PriceHistory[]
  
  @@unique([developerId, apartmentNumber])
  @@map("apartments")
}

// Historia cen
model PriceHistory {
  id                   String    @id @default(cuid())
  apartmentId          String    @map("apartment_id")
  
  oldPrice             Float?    @map("old_price")
  newPrice             Float     @map("new_price")
  priceType            PriceType @map("price_type") // base_price, final_price, price_per_m2
  reason               String?   // Powód zmiany
  
  changedAt            DateTime  @default(now()) @map("changed_at")
  
  // Relations
  apartment            Apartment @relation(fields: [apartmentId], references: [id], onDelete: Cascade)
  
  @@map("price_history")
}

// Logi synchronizacji
model SyncLog {
  id                   String    @id @default(cuid())
  developerId          String    @map("developer_id")
  
  syncDate             DateTime  @map("sync_date")
  syncType             SyncType  @map("sync_type") // manual, automatic, scheduled
  
  // Statystyki
  apartmentsCount      Int       @map("apartments_count")
  
  // Status
  xmlGenerated         Boolean   @default(false) @map("xml_generated")
  filesUploaded        Boolean   @default(false) @map("files_uploaded")
  harvesterSuccess     Boolean?  @map("harvester_success")
  
  // Błędy
  errors               String?   // JSON string z błędami
  
  // URLs wygenerowanych plików
  xmlUrl               String?   @map("xml_url")
  md5Url               String?   @map("md5_url")
  
  createdAt            DateTime  @default(now()) @map("created_at")
  
  // Relations
  developer            Developer @relation(fields: [developerId], references: [id], onDelete: Cascade)
  
  @@map("sync_logs")
}

// Enums
enum DeveloperStatus {
  PENDING
  ACTIVE
  SUSPENDED
  INACTIVE
}

enum PropertyType {
  MIESZKANIE
  DOM
}

enum PriceType {
  BASE_PRICE
  FINAL_PRICE
  PRICE_PER_M2
}

enum SyncType {
  MANUAL
  AUTOMATIC
  SCHEDULED
}

// NextAuth tables
model Account {
  id                String  @id @default(cuid())
  userId            String  @map("user_id")
  type              String
  provider          String
  providerAccountId String  @map("provider_account_id")
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique @map("session_token")
  userId       String   @map("user_id")
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String    @unique
  emailVerified DateTime? @map("email_verified")
  image         String?
  
  // Link to Developer (1:1 relationship)
  developerId   String?   @unique @map("developer_id")
  developer     Developer? @relation(fields: [developerId], references: [id], onDelete: SetNull)
  
  accounts Account[]
  sessions Session[]

  @@map("users")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verificationtokens")
}
